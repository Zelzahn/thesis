\chapter{The Component Model}
\label{chap:component_model}

% [Wat is het component model en waarom willen we het. Ook vertellen dat je het kan zien als een guest/host-architectuur, maar dat het perfect mogelijk is om meerdere componenten samen te weven.]

The WebAssembly Component Model is an architecture for building interoperable \gls{Wasm} liraries, applications and environments. These components can be seen as containers for modules, or other components, which express their interfaces and dependencies via \gls{WIT} and the canonical \gls{ABI}. 
An \gls{ABI} can be seen as an agreement on how to pass around data in a binary format, specifically concerned with the data layout at the bits-and-bytes level. The Canonical \gls{ABI} defined by the component model, specifies how the \gls{WIT} type definitions are translated to bits and bytes. Internally, a C and a Rust component might represent strings in a quite different way, but the canonical \gls{ABI} provides a format for them to pass strings across the boundary between them.

It is important to note, though, that the Component Model is not \gls{WASI} (\texttt{Preview 2}), nor a part of it. By way of comparison to traditional \gls{OS}, the Component Model fills the role of an \gls{OS}'s process model, defining how processes start up and communicate with each other, while \gls{WASI} fills the role of an \gls{OS}'s many I/O interfaces.

It is easiest to think of the Component Model as a guest-host architecture, but it is certainly possible to compose multiple components together. For this, \href{https://github.com/bytecodealliance/cargo-component}{cargo-component} can be used in Rust, or the language-agnostic \href{https://github.com/bytecodealliance/wasm-tools}{wasm-tools}.

\section{WIT}
\label{sec:wit}
% [Schetsen wat WIT is en kort hoe de syntax in elkaar zit. Misschien dat het ook handig kan zijn om uit te leggen hoe dependencies in WIT gemanaged worden.]

\gls{WIT} is an \gls{IDL}. This means that it is a format that defines how the interface of a component should look like. To this end, it uses the following set of concepts: types, functions, interfaces, worlds and packages. From these, worlds are the most key.

A world describes the capabilities and needs of a component - it says which interfaces are available for outside code to call, the \texttt{export}s, and which interfaces it depends on, the \texttt{import}s. Thus, only the surface of a component is defined, not the internal behaviour. The internal behaviour is determined when the world is targeted by a component an application or library developer creates. For a component to run, its imports must be fulfilled, by a host or by other components. \\
On the other hand, a world defines an environment in which a component can be instantiated and its functionality can be invoked.

There are also some small intricacies worth pointing out. For types, two things stand out. First, both the \texttt{char} and \texttt{string} types are Unicode. Second, there's the user-defined \texttt{resource} type. This type can be seen as an object that implements an interface, and therefore behaviour is only exposed through methods. \\
Furthermore, functions can only be declared as part of an interface, or as an import or exprot in a world. Finally, a package is not a world, but can be seen as more like a namespace. It's a way of grouping related interfaces and worlds together for ease of discovery and reference.


To make managing dependencies inside your \gls{WIT} definition easier, the \href{https://github.com/bytecodealliance/wit-deps}{wit-deps} project can be used. It makes it possible to lock your dependencies to a certain version and to check if they're the most recent one.

\subsection{\texttt{witx}}

In older tooling, it is possible to come across \texttt{witx} instead of \gls{WIT}. This was the \gls{IDL} used during \texttt{Preview 1}. It was derived from \texttt{wat}, see chapter~\ref{chap:wasm}, and had a low-level C-like type system that emphasized raw pointers, and callees were expected to have access to the entir lineair memory of the caller.
 
\section{Guest}
\label{sec:guest}
% [Op welke manieren kan je allemaal code schrijven dat dan naar een preview 2 component gecompileerd kan worden. Verschillende tooling over programmeertalen heen de specifieke voor Rust. Alsook hoe we van preview1 component naar preview2 kunnen gaan.]

In Rust, \texttt{cargo-component} can be used to compile code to a preview 2 component. In essence, compiling to \texttt{Preview 2} means compiling to \texttt{wasm32-wasi} and then converting it to a component via an adapater and the \texttt{wasm-tools component new} subcommand. This component then adheres to the \gls{WIT} interface specified in the configuration file. The adaption is needed because there's no first-class support for \texttt{Preview 2} yet. Mainstream support for this is planned for early 2025~\cite{rust:p2}.

Under the hood, \texttt{cargo-component} relies upon \href{https://github.com/bytecodealliance/wit-bindgen}{wit-bindgen} for binding with the interface. Besides Rust, \texttt{wit-bindgen} also supports the following languages: C, Java, Go and C\#. For JavaScript, \href{https://github.com/bytecodealliance/ComponentizeJS}{ComponentizeJS} can be used.

\subsection{Adapter modules}

The Wasmtime runtime publishes adapter modules with each release, they provide the bridge between the \texttt{Preview 1} \gls{ABI} and the \texttt{Preview 2} \gls{ABI}. The following three modules are provided:

\begin{itemize}
    \item Command: For command-line applications
    \item Reactor: Applications that don't have a \texttt{main} function
    \item Proxy: For applications fed into \texttt{wasmtime serve}
\end{itemize}

The \texttt{wasmtime serve} subcommand runs a component inside the \texttt{wasi:http/proxy} world, supporting the sending and receiving of HTTP requests.

\section{Host}
\label{sec:host}
% [Uitlegen dat je runtimes hebt en dat je rechtstreeks daarop kan draaien of dat er ook visence, compiling to preview 2 means compiling to \gls{Wasm} and then converting it to a component via an adapater.

The job of the host is to load a component and execute it through the usage of a \gls{Wasm} runtime. See section~\ref{sec:runtimes} for a shortlist of the available ones. To guarantee a correct execution, it is important to make sure that any missing interface imports are filled in here, see the earlier section~\ref{sec:wit}. When using \texttt{wit-bindgen}, this is done via the \texttt{with} option inside the \href{https://docs.rs/wasmtime/latest/wasmtime/component/macro.bindgen.html}{the \texttt{bindgen} macro}.

It is also possible to execute a component via the \texttt{wasmtime run} subcommand. This will compile the module to native code, instantiate it and optionally execute an export.


\section{Problems}
% [hier iets vertellen over dat het gebruik maken van het component model wel wat nadelen inhoudt, zoals extra geheugen dat nodig is enzo, waardoor het niet altijd gewenst is voor dit te gebruiken. Of toch zeker momenteel op hele zwakke MCU's]

[Hier kan er misschien iets verteld worden over de argumenten om component model niet te gebruiken? Is dit wel nuttig en willen we dat wel?]
