\section{WebAssembly System Interface}
\label{sec:wasi}

\gls{WASI}~\cite{wasi} is a modular collection of \gls{API}'s defined with the \gls{WIT} IDL. It provides a secure and portable way to access several operating-system-like features such as filesystems, networking, clocks and random numbers. This collection is developed under the governance of the \gls{WASI} Subgroup, a subgroup of the WebAssembly Community Group.

In this subgroup, the following design principles are core:

\begin{itemize}
    \item Capability-based security: All access to external resources is provided by capabilities, see chapter~\ref{chap:component_model}.
    \item Interposition: A Webassembly instance can implement a given WASI interface, and the consumer WebAssembly instance can then use this implementation transparently.
    \item Compatibility: If possible, keep the \gls{API} free of Compatibility concerns, and provide compatibility through libraries.
    \item Portability: The exact meaning of this is specific to each \gls{API}, but in globo it means that no engine should need to implement every \gls{API} in \gls{WASI}.
    \item Modularity: The component model's worlds mechanism is used, in order to allow specific sets of APIs to be described which meet the needs of different environments. See chapter~\ref{chap:component_model}.
\end{itemize}


% [Hier vergelijking met docker doen.]

\subsection{WIT}
\label{sec:wit}
% [Schetsen wat WIT is en kort hoe de syntax in elkaar zit. Misschien dat het ook handig kan zijn om uit te leggen hoe dependencies in WIT gemanaged worden.]

\gls{WIT} is an \gls{IDL}. This means that it is a format that defines how the interface of a component should look like. To this end, it uses the following set of concepts: types, functions, interfaces, worlds and packages. From these, worlds are the most key.

A world describes the capabilities and needs of a component - it says which interfaces are available for outside code to call, the \texttt{export}s, and which interfaces it depends on, the \texttt{import}s. Thus, only the surface of a component is defined, not the internal behaviour. The internal behaviour is determined when the world is targeted by a component an application or library developer creates. For a component to run, its imports must be fulfilled, by a host or by other components. \\
On the other hand, a world defines an environment in which a component can be instantiated and its functionality can be invoked.

There are also some small intricacies worth pointing out. For types, two things stand out. First, both the \texttt{char} and \texttt{string} types are Unicode. Second, there's the user-defined \texttt{resource} type. This type can be seen as an object that implements an interface, and therefore behaviour is only exposed through methods. \\
Furthermore, functions can only be declared as part of an interface, or as an import or exprot in a world. Finally, a package is not a world, but can be seen as more like a namespace. It's a way of grouping related interfaces and worlds together for ease of discovery and reference.


To make managing dependencies inside your \gls{WIT} definition easier, the \href{https://github.com/bytecodealliance/wit-deps}{wit-deps} project can be used. It makes it possible to lock your dependencies to a certain version and to check if they're the most recent one.

\subsubsection{\texttt{witx}}

In older tooling, it is possible to come across \texttt{witx} instead of \gls{WIT}. This was the \gls{IDL} used during \texttt{Preview 1}. It was derived from \texttt{wat}, see chapter~\ref{chap:wasm}, and had a low-level C-like type system that emphasized raw pointers, and callees were expected to have access to the entir lineair memory of the caller.

\subsection{Versions}
\label{sec:versions}
At the time of writing, \gls{WASI} is in \texttt{Preview 2}. The flagship feature of this preview is the release of the component model, see section~\ref{chap:component_model}. Furthermore, two \gls{WIT} worlds are now included:

\begin{itemize}
    \item \texttt{wasi-cli}: A command-line interface, roughly corresponding to \texttt{POSIX}.
    \item \texttt{wasi-http}: An \texttt{HTTP} proxy.
\end{itemize}

The major banner of the upcoming \texttt{0.3} is asynchronous support. The exact details of what this asynchrony entails is yet to be determined. Following up will be a stable 1.0 release.

\subsection{Runtimes}
\label{sec:runtimes}
% [Wasmtime uitvoerig bespreken, maar ook de meest belangrijke andere runtimes. Het is niet de bedoeling om echt in depth te gaan vergelijken en te benchmarken, maar om gewoon wat te schetsen wat er allemaal is. Daarnaast ook vertellen in welke mate, en hoe, je een preview2 component op een runtime kan laten draaien dat geen support heeft voor het component model. Misschien ook kort iets rond changes die in Wasmtime kunnen gebeuren om meer embedded devices te supporten.]

A runtime system is a binary that is accountable for the running of \gls{Wasm} binaries. Analogue to the role of a hypervisor for a virtual machine. The Bytecode Alliance maintains two runtimes, \href{https://github.com/bytecodealliance/wasmtime}{Wasmtime} and \href{https://github.com/bytecodealliance/wasm-micro-runtime}{WAMR}.

Wasmtime can be seen as a general-purpose runtime, focussing on server-side and non-web embeddings with components. It has full component model support, first-class support for eight languages, and community support for a further two. This makes it the de-facto runtime. 

On the other hand, \gls{WAMR} is specifically designed to be as lightweight as possible, targeting embedded devices and the edge. This translates itself into the provided features and the supported guest languages. Support for the component model is planned for the end of 2024, and it only has robust support for C/C++. A toolkit for Rust has been published in March 2024, but this is still novel.

In Rust, the standard library, abbreviated as \texttt{std}, is a set of minimal shared abstractions for the broader Rust ecosystem. This library is enabled by default, and can be opted out via the \texttt{no\_std} attribute. Rejection is useful when targeting a platform that does not support the library or purposfully doesn't use the capabilities of \texttt{std}. Historically, the community surrounding Wasmtime has been strongly opposed to the inclusion of a \texttt{no\_std} build. This is no longer the case. When such a build will eventually be available, the gap between Wasmtime and \gls{WAMR} will be reduced.

Besides these two, there are numerous ones provided by other parties, in varying degrees of completeness, targeting other use-cases. There's for example \href{https://github.com/bytecodealliance/jco}{jco}, specialized for JavaScript, \href{https://github.com/bytecodealliance/componentize-py}{componentize.py}, for Python, or \href{https://github.com/dylibso/chicory}{Chicory}, which runs on the Java \gls{VM}. These are out-of-scope for this dissertation.
